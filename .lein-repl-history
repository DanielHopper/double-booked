t2
t3
t4
t5
(combo/combinations [t1 t2 t3 t4 t5] 2)
(defn filter-fn [event-pair]
  (or  (and (<= (get (first event-pair) :start) (get (second event-pair) :end))
            (>= (get (first event-pair) :end) (get (second event-pair) :start)))
       (and (<= (get (second event-pair) :start) (get (first event-pair) :end))
            (>= (get (second event-pair) :end) (get (first event-pair) :start)))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts [t1 t2 t3 t4 t5])
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs   (combo/combinations list-of-events 2)]
    (map make-conflict (filter filter-fn event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(distinct (get-conflicts-naive [t1 t2 t3 t4 t5]))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs   (combo/combinations list-of-events 2)]
    (filter filter-fn event-pairs)))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5])
(distinct (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))
(get-conflicts [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5])
(distinct (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))
(time (dorun (distinct (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))))
(time (dorun (distinct (get-conflicts [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))))
(time (dorun (distinct (get-conflicts [t1 t2 t3 t4 t5]))))
(time (dorun (distinct (get-conflicts-naive [t1 t2 t3 t4 t5]))))
(time (dorun (distinct (map to-time-maps [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))))
(time (dorun (distinct (map to-time-maps [t1 t2]))))
(time (dorun (get-conflicts-naive [t1 t2]))))
(time (dorun (get-conflicts-naive [t1 t2])))
(time (dorun (get-conflicts-naive [t1 t2 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t2 t2 t1 t1 t1 t1 t1])))
(time (dorun (get-conflicts [t1 t2 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t2 t2 t1 t1 t1 t1 t1])))
(assoc {} :me 'me)
(defn make-event [name start end]
  (->Event name (/ (c/to-long start) 3600000) (/ (c/to-long end) 3600000)))
(def t1 (make-event "My Birthweek" "1995-05-31" "1995-06-07"))
(def t2 (make-event "My Birthday" "1995-05-31" "1995-06-01"))
(def t3 (make-event "First of June" "1995-06-01" "1995-06-02"))
(def t4 (make-event "Winter Break" "1995-12-22" "1996-01-05"))
(def t5 (make-event "Christmas" "1995-12-25" "1995-12-26"))
(time (dorun (get-conflicts-naive [t1 t2])))
(time (dorun (get-conflicts [t1 t2])))
(time (dorun (get-conflicts [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(defrecord EventComponent [timestamp type name])
(defn event-to-components [e]
  [(->EventComponent (get e :start) 'start (get e name))
   (->EventComponent (get e :end) 'end (get e name))])
(equal? 'start 'start)
(eq? 'start 'start)
(eq 'start 'start)
= 'start 'start)
(= 'start 'start)
(combo
)
(combo)
(combo/combinations [1 2 3] 2)
(combo/combinations [1 2] 2)
(combo/combinations [1] 2)
(combo/combinations [1 2 3] 4)
(defn walk-intervals [components active conflicts]
  (cond
    [(empty? components) conflicts]
    [(= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))]
    [(= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       conflicts))]))
(defn walk-intervals [components active conflicts]
  (cond
    [(empty? components) conflicts]
    [(= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))]
    [(= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       conflicts))]
    :else
      "Event components were mislabeled"))
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       conflicts))))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (first x)) components)]
    (walk-intervals sorted components [] [])))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (first x)) components)]
    (walk-intervals sorted-components [] [])))
(get-conflicts-intervals [a b])
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) components)]
    (walk-intervals sorted-components [] [])))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations (coll next-active) 2))))
    (= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
[]
(seq [])
(seq [2 3])\
(seq [2 3])
(combo/combinations [1 2 4] 2)
(combo/combinations (set [1 2 4]) 2)
(map event-to-components [a b])
(defn event-to-components [e]
  [(->EventComponent (get e :start) 'start (get e :name))
   (->EventComponent (get e :end) 'end (get e :name))])
(map event-to-components [a b])
(get-conflicts-intervals [a b])
(map event-to-components [a b])
(def components (map event-to-components [a b]))
(sort-by (fn [x] (get x :timestamp)) components)
(sort-by (fn [x] (get x :name)) components)
(sort-by (fn [x] (get x :type)) components)
(sort-by (fn [x] (get x :name)) components)
components
(flatten components)
(sort-by (fn [x] (get x :timestamp)) (flatten components))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) (flatten components))]
    (walk-intervals sorted-components (set []) [])))
(get-conflicts-intervals [a b])
(sort-by (fn [x] (get x :timestamp)) (flatten components))
(def s-comp (sort-by (fn [x] (get x :timestamp)) (flatten components)))
s-comp
(first s-comp)
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (get (first components) :type))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (get (first components) :type))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (map make-conflict (combo/combinations next-active 2)))))
    (= 'end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) (flatten components))]
    (walk-intervals sorted-components (set []) [])))
(get-conflicts-intervals [a b])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(time (dorun (get-conflicts-intervals [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-intervals [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (conj conflicts (map make-conflict (combo/combinations next-active 2)))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(defn event-to-components [e]
  [(->EventComponent (get e :start) :start (get e :name))
   (->EventComponent (get e :end) :end (get e :name))])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(set [])
(conj (set []) :a_
)
(conj (conj (set []) :a_) :a_)
(combo/combinations (conj (conj (set []) :a_) :a_) 2)
(combo/combinations (conj (conj (set []) :a_) :a_) 1)
(get-conflicts-intervals [t2 t3 t4 t5 t1])
(flatten (get-conflicts-intervals [t2 t3 t4 t5 t1]))
(def t6 (make-event "Nest1" "2017-05-01" "2017-05-31"))
(def t7 (make-event "Nest2" "2017-05-05" "2017-05-17"))
(def t8 (make-event "Nest3" "2017-05-07" "2017-05-18"))
(def t9 (make-event "Nest4" "2017-05-07" "2017-05-08"))
(def t10 (make-event "Nest5" "2017-05-07T12:00:04" "2017-05-07:12:04:04"))
(def t10 (make-event "Nest5" "2017-05-07T12:00:04" "2017-05-07T12:04:04"))
(flatten (get-conflicts-intervals [t6 t7 t8 t9 t10]))
(distinct (flatten (get-conflicts-intervals [t6 t7 t8 t9 t10])))
(flatten (get-conflicts-naive [t6 t7 t8 t9 t10]))
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (make-conflict ((get (first x) :name) (get (second x) :name))))
         (filter overlap? event-pairs))))
(defn overlap? [event-pair]
  (or  (and (<= (get (first event-pair) :start) (get (second event-pair) :end))
            (>= (get (first event-pair) :end) (get (second event-pair) :start)))
       (and (<= (get (second event-pair) :start) (get (first event-pair) :end))
            (>= (get (second event-pair) :end) (get (first event-pair) :start)))))
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (make-conflict ((get (first x) :name) (get (second x) :name))))
         (filter overlap? event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (make-conflict [(get (first x) :name) (get (second x) :name)]))
         (filter overlap? event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts-naive [t6 t7 t8 t9 t10])
(get-conflicts-intervals [t6 t7 t8 t9 t10])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) (distinct (flatten conflicts))
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (conj conflicts (map make-conflict (combo/combinations next-active 2)))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(get-conflicts-intervals [t6 t7 t8 t9 t10])
(get-conflicts-naive [t6 t7 t8 t9 t10])
(defrecord EventConflict [event1 event2])
(get-conflicts-naive [t6 t7 t8 t9 t10])
(get-conflicts-intervals [t6 t7 t8 t9 t10])
(get-conflicts-intervals [t6 t7 t8 t9 t10 t1 t3 t4 t5 t2])
(get-conflicts-naive [t6 t7 t8 t9 t10 t1 t3 t4 t5 t2])
(time (dorun (get-conflicts-naive [t6 t7 t8 t9 t10 t1 t3 t4 t5 t2])))
(time (dorun (get-conflicts-intervals [t6 t7 t8 t9 t10 t1 t3 t4 t5 t2])))
(time (dorun (get-conflicts-intervals [t6 t7 t8 t9 t10])))
(time (dorun (get-conflicts-maive [t6 t7 t8 t9 t10])))
(time (dorun (get-conflicts-naive [t6 t7 t8 t9 t10])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-intervals [t1 t2 t3 t4 t5])))
(set [])
#{}
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (union conflicts (combo/combinations next-active 2))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(union #{1 2} #{3})
(set/union #{1 2} #{3})
(require '[clojure.set :as set])
(set/union #{1 2} #{3})
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (union conflicts (combo/combinations next-active 2))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (set/union conflicts (combo/combinations next-active 2))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) (flatten components))]
    (walk-intervals sorted-components #{} #{})))
(get-conflicts-intervals [t2 t3 t4 t5])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] [(get (first x) :name) (get (second x) :name)]) (filter overlap? event-pairs))))
(get-conflicts-intervals [t2 t3 t4 t5])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (set/union conflicts (set (combo/combinations next-active 2)))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(combo/combinations #{3 5 7} 2)
(def active (combo/combinations #{3 5 7} 2))
(set/union active (combo/combinations #{3 5} 2))
active
(set (combo/combinations #{3 5 7} 2))
(def active-set (set (combo/combinations #{3 5 7} 2)))
(set/union active-set (combo/combinations #{3 5} 2))
(set/union active-set (set (combo/combinations #{3 5} 2)))
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (set/union conflicts (set (combo/combinations next-active 2)))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) (flatten components))]
    (walk-intervals sorted-components #{} #{})))
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(get-conflicts-naive [t1 t2 t3 t4 t5])
(set 4 5)
(set [4 5])
(defn overlap? [event-pair]
  (or  (and (< (get (first event-pair) :start) (get (second event-pair) :end))
            (> (get (first event-pair) :end) (get (second event-pair) :start)))
       (and (< (get (second event-pair) :start) (get (first event-pair) :end))
            (> (get (second event-pair) :end) (get (first event-pair) :start)))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
         (filter overlap? event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) (seq conflicts)
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (set/union conflicts (set (combo/combinations next-active 2)))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(time (dorun (get-conflicts-intervals [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-intervals [t1 t2 t3 t4 t5 t6 t7 t8 t9 t10])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5 t6 t7 t8 t9 t10])))
(map (fn [x] x) #{1 2 3 4})
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (set (combo/combinations list-of-events 2))]
    (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
         (filter overlap? event-pairs)))))
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (set (combo/combinations list-of-events 2))]
    (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
         (filter overlap? event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (set/union conflicts (set (combo/combinations next-active 2)))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
         (filter overlap? event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(filter (fn [x] (> x 2)) #{1 2 3 4 5})
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
         (set (filter overlap? event-pairs)))))
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
         (set (filter overlap? event-pairs)))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(seq 1 2)
(quote 2 3)
(quote 2)
'(2 3 4 )
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] '((get (first x) :name) (get (second x) :name))))
         (filter overlap? event-pairs))))
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] '((get (first x) :name) (get (second x) :name)))
         (filter overlap? event-pairs))))
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (get (first x) :name) (get (second x) :name))
         (filter overlap? event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
         (filter overlap? event-pairs))))
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs (combo/combinations list-of-events 2)]
    (set (map (fn [x] (seq [(get (first x) :name) (get (second x) :name)]))
              (filter overlap? event-pairs)))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(get-conflicts-intervals [t1 t2 t3 t4 t5 t6 t7 t8 t9 t10])
(get-conflicts-naive [t1 t2 t3 t4 t5 t6 t7 t8 t9 t10])
(first (get-conflicts-naive [t1 t2 t3 t4 t5 t6 t7 t8 t9 t10]))
(second (get-conflicts-naive [t1 t2 t3 t4 t5 t6 t7 t8 t9 t10]))
(set/union #{3 4 5} #{3 4})
'("Winter Break" "Christmas")
(= (1 2) (2 1))
(= '(1 2) '(2 1))
(= #{1 2} #{2 1})
(get-conflicts-naive [t6 t7 t8 t9 t10])
(map (fn [x] (set x)) (get-conflicts-naive [t6 t7 t8 t9 t10]))
(def aa '(1 2 3))
aa
(def aa '(1 1 1))
aa
(set aa)
