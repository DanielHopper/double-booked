(reducers/fold + '(1 2 3 4))
(defn get-calendar-map [list-of-events]
  (reducers/fold (fn [xs x] (merge-with into x xs)) (map to-time-maps list-of-events)))
(get-calendar-map {} [a b])
(get-calendar-map [a b])
a
b
(get-calendar-map [a b])
(get-calendar-map {})
(defn diddly ([xs ([] []))
(defn get-calendar-map [list-of-events]
  (reducers/fold diddly (map to-time-maps list-of-events)))
(get-calendar-map [a b])
(defn combinef ([xs x] (merge-with into x xs)) ([] {})
)
(defn get-calendar-map [list-of-events]
  (reducers/fold combinef (map to-time-maps list-of-events)))
(get-calendar-map [a b])
(seq (get-calendar-map [a b]))
(filter (fn [x y] (> (count y) 1)) (seq (get-calendar-map [a b]))) 
(filter (fn [x] (> (count (second x)) 1)) (seq (get-calendar-map [a b]))) 
(def conflicts (filter (fn [x] (> (count (second x)) 1)) (seq (get-calendar-map [a b]))))
conflicts
(require '[clojure.math.combinatorics :as combo])
classpath
(require '[org.clojure.math.combinatorics :as combo])
(require '[clojure.math.combinatorics :as combo])
(require [clojure.math.combinatorics :as combo])
combo
(:require [clojure.math.combinatorics :as combo])
exit
combo
(require [clojure.math.combinatorics])
(require '[clojure.math.combinatorics])
(ns example.core
  (:require [clojure.math.combinatorics :as combo]))
(require '[clojure.math.combinatorics])
(require '[org.clojure.math.combinatorics])
(require '[clojure/math.combinatorics])
(require '[clojure.math.combinatorics])
(require '[double-booked.core])
exit
(require '[double-booked.core])
exit
(require '[double-booked.core])
exit
combo
exit
combo
(require '[clojure.math.combinatorics :as combo])
(defrecord Rin [t y o])
(Rin :r :g:)
(Rin :r :g)
(Rin. :r :g)
(Rin. :r :g :u)
(empty? [])
(Rin. :r :g :u)
(Rin. :r :g :u).t
(get (Rin. :r :g :u) t
)
(get (Rin. :r :g :u) t)
(get (Rin. :r :g :u) :t)
(defrecord Event [name start end])
(get (def a (Event. "My Birthday" "05-31-95T00:00:00" "05-31-95T23:59:59")) name)
(get (def a (Event. "My Birthday" "05-31-95T00:00:00" "05-31-95T23:59:59")) :name)
(get (Event. "My Birthday" "05-31-95T00:00:00" "05-31-95T23:59:59") :name)
(into ["adsad"] ["bbb" "ccc"])
(defn to-time-maps [e]
  (into (hash-map) (let name  (get e :name)
                        start (get e :start)
                        end   (get e :end)]
                     (for [time (range start end)]
                       [time [name]]))))
(defn to-time-maps [e]
  (into (hash-map) (let [name   (get e :name)
                         start  (get e :start)
                         end    (get e :end)]
                     (for [time (range start end)]
                       [time [name]]))))
(defrecord Event [name start end])
(def a (Event. "My Birthday" "05-31-95T00:00:00" "05-31-95T23:59:59"))
(def a (Event. "My Birthday" 12 15))
(def b (Event. "Your Birthday" 14 17))
(defn get-calendar-map [list-of-events]
  (merge-with into (map to-time-maps list-of-events)))
(get-calendar-map [a b])
(map to-time-maps [a b])
(defn to-time-maps [e]
  (into (hash-map) (let [name   (get e :name)
                         start  (get e :start)
                         end    (get e :end)]
                     (for [time (range start (+ end 1))]
                       [time [name]]))))
(map to-time-maps [a b])
(get-calendar-map [a b])
(get-calendar-map {} [a b])
(fold + '(1 2 3 4))
(reducers/fold + '(1 2 3 4))
(require '[clojure.core.reducers :as reducers])
(reducers/fold + '(1 2 3 4))
(defn get-calendar-map [list-of-events]
  (reducers/fold (fn [xs x] (merge-with into x xs)) (map to-time-maps list-of-events)))
(get-calendar-map {} [a b])
(get-calendar-map [a b])
a
b
(get-calendar-map [a b])
(get-calendar-map {})
(defn diddly ([xs ([] []))
(defn get-calendar-map [list-of-events]
  (reducers/fold diddly (map to-time-maps list-of-events)))
(get-calendar-map [a b])
(defn combinef ([xs x] (merge-with into x xs)) ([] {})
)
(defn get-calendar-map [list-of-events]
  (reducers/fold combinef (map to-time-maps list-of-events)))
(get-calendar-map [a b])
(seq (get-calendar-map [a b]))
(filter (fn [x y] (> (count y) 1)) (seq (get-calendar-map [a b]))) 
(filter (fn [x] (> (count (second x)) 1)) (seq (get-calendar-map [a b]))) 
(def conflicts (filter (fn [x] (> (count (second x)) 1)) (seq (get-calendar-map [a b]))) )
conflicts
(combo/combinations conflicts 2)
(map conflicts (fn [x] (combo/combinations (second conflicts) 2)))
(map conflicts (fn [x] (combo/combinations (second x) 2)) conflicts
)
(map conflicts (fn [x] (combo/combinations (second x) 2)))
(map (fn [x] (combo/combinations (second x) 2)) conflicts)
(flatten (map (fn [x] (combo/combinations (second x) 2)) conflicts))
(map (fn [x] (combo/combinations (second x) 2)) conflicts)
(map (fn [x] (EventConflict. (combo/combinations (second x) 2)) conflicts)
)
(defrecord EventConflict [name1 name2])
(map (fn [x] (EventConflict. (combo/combinations (second x) 2)) conflicts)
)
(defn make-conflict [event-names]
  (->EventConflict (first event-names) (second event-names)))
(map (fn [x] (make-conflict (combo/combinations (second x) 2)) conflicts))
(map (fn [x] (map make-conflict (combo/combinations (second x) 2))) conflicts)
(flatten (map (fn [x] (map make-conflict (combo/combinations (second x) 2))) conflicts))
(unique (flatten (map (fn [x] (map make-conflict (combo/combinations (second x) 2))) conflicts)))
(distinct (flatten (map (fn [x] (map make-conflict (combo/combinations (second x) 2))) conflicts)))
(defn collect-conflicts [list-of-events]
  (let [conflicting-events  (filter
                              (fn [x] (> (count (second x)) 1))
                              (seq (get-calendar-map [a b])))
        conflict-pairs      (map
                              (fn [x] (map make-conflict (combo/combinations (second x) 2)))
                              conflicting-events)]
    (flatten conflict-pairs)))
(defn get-conflicts [list-of-events]
  (distinct (collect-conflicts list-of-events)))
(get-conflicts [a b])
(def t1 (Event. "My Birthweek" "05-31-95" "06-07-95"))
(def t2 (Event. "My Birthday" "05-31-95" "06-01-95"))
(def t3 (Event. "First of June" "06-01-95" "06-02-95"))
(def t4 (Event. "Winter Break" "12-22-95" "01-05-96"))
(def t5 (Event. "Christmas" "12-25-95" "12-26-95"))
(get-conflicts [t1 t2 t3 t4 t5])
(defn collect-conflicts [list-of-events]
  (let [conflicting-events  (filter
                              (fn [x] (> (count (second x)) 1))
                              (seq (get-calendar-map [list-of-events])))
        conflict-pairs      (map
                              (fn [x] (map make-conflict (combo/combinations (second x) 2)))
                              conflicting-events)]
    (flatten conflict-pairs)))
(get-conflicts [t1 t2 t3 t4 t5])
(get-conflicts [t1 t2 t3 t4])
(get-conflicts [t1 t2 t3])
(get-conflicts [t1 t2])
(c/to-long "05-31-95")
(require '[clj-time.coerce :as c])
(c/to-long "05-31-95")
(c/to-long "05-31-17")
(c/to-long "05-31-2017")
(c/to-long "2017-05-31")
(def t1 (Event. "My Birthweek" "1995-05-31" "1995-06-07"))
(def t2 (Event. "My Birthday" "1995-05-31" "1995-06-01-95"))
(def t3 (Event. "First of June" "1995-06-01" "1995-06-02"))
(def t4 (Event. "Winter Break" "1995-12-22" "1996-01-05"))
(def t5 (Event. "Christmas" "1995-12-25" "1995-12-26"))
(get-conflicts [t1 t2 t3 t4 t5])
(get-conflicts [t1 t2])
(c/to-long "1995-12-25")
(defn make-event [name start end]
  (->Event name (c/to-long start) (c/to-long end)))
(make-event "my birhday" "1995-05-31" "1995-06-01")
(def t1 (make-event "My Birthweek" "1995-05-31" "1995-06-07"))
(def t2 (make-event "My Birthday" "1995-05-31" "1995-06-01-95"))
(def t3 (make-event "First of June" "1995-06-01" "1995-06-02"))
(def t4 (make-event "Winter Break" "1995-12-22" "1996-01-05"))
(def t5 (make-event "Christmas" "1995-12-25" "1995-12-26"))
t5
(get-conflicts [t1 t2 t3 t4 t5])
a
t1
t2
(def t2 (make-event "My Birthday" "1995-05-31" "1995-06-01"))
(get-conflicts [t1 t2 t3 t4 t5])
t1
t2
t3
t4
t5
(get-conflicts [a b])
(collect-conflicts [a b])
(get-calendar-map [a b])
(get-calendar-map [t1 t2 t3 t4 t5])
(/ 819936000000 60000)
(defn make-event [name start end]
  (->Event name (/ (c/to-long start) 60000) (/ (c/to-long end) 60000)))
(t1
)
t1
(def t1 (make-event "My Birthweek" "1995-05-31" "1995-06-07"))
(def t2 (make-event "My Birthday" "1995-05-31" "1995-06-01"))
(def t3 (make-event "First of June" "1995-06-01" "1995-06-02"))
(def t4 (make-event "Winter Break" "1995-12-22" "1996-01-05"))
(def t5 (make-event "Christmas" "1995-12-25" "1995-12-26"))
t1
t2
(get-calendar-map [t1 t2 t3 t4 t5])
(collect-conflicts [a b])
(defn collect-conflicts [list-of-events]
  (let [conflicting-events  (filter
                              (fn [x] (> (count (second x)) 1))
                              (seq (get-calendar-map list-of-events)))
        conflict-pairs      (map
                              (fn [x] (map make-conflict (combo/combinations (second x) 2)))
                              conflicting-events)]
    (flatten conflict-pairs)))
(collect-conflicts [a b])
(collect-conflicts [t1 t2 t3 t4 t5])
(get-conflicts [t1 t2 t3 t4 t5])
(get-conflicts [t1 t2 t3 t4 t5 t2 t2 t2 t2 t2 t2 t2 t2])
(get-conflicts [t1 t2 t3 t4 t5 t2 t2 t2 t2 t2 t2 t2 t2 t3 t3 t3 t3 t3 t3 t3 t2 t3 t3 t3 t5 t7 t4 t1 t4 t9])
(get-conflicts [t1 t2 t3 t4 t5 t2 t2 t2 t2 t2 t2 t2 t2 t3 t3 t3 t3 t3 t3 t3 t2 t3 t3 t3 t5 t4 t1 t4])
(combo/combinations [t1 t2 t3 t4 t5])
(combo/combinations [t1 t2 t3 t4 t5] 2)
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs   (combo/combinations list-of-events 2)]
    (filter filter-fn event-pairs)))
(defn filter-fn [event-pair]
  (or (< (get start (first event-pair)) (get end (second event-pair)))
      (< (get start (second event-pair)) (get end (first event-pair)))))
(defn filter-fn [event-pair]
  (or  (and (<= (get :start (first event-pair)) (get :end (second event-pair)))
            (>= (get :end (first event-pair)) (get :start (second event-pair))))
       (and (<= (get :start (second event-pair)) (get :end (first event-pair)))
            (>= (get :end (second event-pair)) (get :start (first event-pair))))))
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs   (combo/combinations list-of-events 2)]
    (filter filter-fn event-pairs)))
(get-conflicts-naive [t1 t2 t3 t4 t5])
t1
t2
t3
t4
t5
(combo/combinations [t1 t2 t3 t4 t5] 2)
(defn filter-fn [event-pair]
  (or  (and (<= (get (first event-pair) :start) (get (second event-pair) :end))
            (>= (get (first event-pair) :end) (get (second event-pair) :start)))
       (and (<= (get (second event-pair) :start) (get (first event-pair) :end))
            (>= (get (second event-pair) :end) (get (first event-pair) :start)))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts [t1 t2 t3 t4 t5])
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs   (combo/combinations list-of-events 2)]
    (map make-conflict (filter filter-fn event-pairs))))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(distinct (get-conflicts-naive [t1 t2 t3 t4 t5]))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(defn get-conflicts-naive [list-of-events]
  (let [event-pairs   (combo/combinations list-of-events 2)]
    (filter filter-fn event-pairs)))
(get-conflicts-naive [t1 t2 t3 t4 t5])
(get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5])
(distinct (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))
(get-conflicts [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5])
(distinct (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))
(time (dorun (distinct (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))))
(time (dorun (distinct (get-conflicts [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))))
(time (dorun (distinct (get-conflicts [t1 t2 t3 t4 t5]))))
(time (dorun (distinct (get-conflicts-naive [t1 t2 t3 t4 t5]))))
(time (dorun (distinct (map to-time-maps [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t5]))))
(time (dorun (distinct (map to-time-maps [t1 t2]))))
(time (dorun (get-conflicts-naive [t1 t2]))))
(time (dorun (get-conflicts-naive [t1 t2])))
(time (dorun (get-conflicts-naive [t1 t2 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t2 t2 t1 t1 t1 t1 t1])))
(time (dorun (get-conflicts [t1 t2 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t1 t2 t2 t1 t1 t1 t1 t1])))
(assoc {} :me 'me)
(defn make-event [name start end]
  (->Event name (/ (c/to-long start) 3600000) (/ (c/to-long end) 3600000)))
(def t1 (make-event "My Birthweek" "1995-05-31" "1995-06-07"))
(def t2 (make-event "My Birthday" "1995-05-31" "1995-06-01"))
(def t3 (make-event "First of June" "1995-06-01" "1995-06-02"))
(def t4 (make-event "Winter Break" "1995-12-22" "1996-01-05"))
(def t5 (make-event "Christmas" "1995-12-25" "1995-12-26"))
(time (dorun (get-conflicts-naive [t1 t2])))
(time (dorun (get-conflicts [t1 t2])))
(time (dorun (get-conflicts [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(defrecord EventComponent [timestamp type name])
(defn event-to-components [e]
  [(->EventComponent (get e :start) 'start (get e name))
   (->EventComponent (get e :end) 'end (get e name))])
(equal? 'start 'start)
(eq? 'start 'start)
(eq 'start 'start)
= 'start 'start)
(= 'start 'start)
(combo
)
(combo)
(combo/combinations [1 2 3] 2)
(combo/combinations [1 2] 2)
(combo/combinations [1] 2)
(combo/combinations [1 2 3] 4)
(defn walk-intervals [components active conflicts]
  (cond
    [(empty? components) conflicts]
    [(= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))]
    [(= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       conflicts))]))
(defn walk-intervals [components active conflicts]
  (cond
    [(empty? components) conflicts]
    [(= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))]
    [(= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       conflicts))]
    :else
      "Event components were mislabeled"))
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest conflicts)
                       next-active
                       conflicts))))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (first x)) components)]
    (walk-intervals sorted components [] [])))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (first x)) components)]
    (walk-intervals sorted-components [] [])))
(get-conflicts-intervals [a b])
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) components)]
    (walk-intervals sorted-components [] [])))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (first components))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations (coll next-active) 2))))
    (= 'end (first components))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
[]
(seq [])
(seq [2 3])\
(seq [2 3])
(combo/combinations [1 2 4] 2)
(combo/combinations (set [1 2 4]) 2)
(map event-to-components [a b])
(defn event-to-components [e]
  [(->EventComponent (get e :start) 'start (get e :name))
   (->EventComponent (get e :end) 'end (get e :name))])
(map event-to-components [a b])
(get-conflicts-intervals [a b])
(map event-to-components [a b])
(def components (map event-to-components [a b]))
(sort-by (fn [x] (get x :timestamp)) components)
(sort-by (fn [x] (get x :name)) components)
(sort-by (fn [x] (get x :type)) components)
(sort-by (fn [x] (get x :name)) components)
components
(flatten components)
(sort-by (fn [x] (get x :timestamp)) (flatten components))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) (flatten components))]
    (walk-intervals sorted-components (set []) [])))
(get-conflicts-intervals [a b])
(sort-by (fn [x] (get x :timestamp)) (flatten components))
(def s-comp (sort-by (fn [x] (get x :timestamp)) (flatten components)))
s-comp
(first s-comp)
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (get (first components) :type))
     (let [next-active (conj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (get (first components) :type))
     (let [next-active (disj active (first components))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (combo/combinations next-active 2))))
    (= 'end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(get-conflicts-intervals [a b])
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= 'start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       (conj conflicts (map make-conflict (combo/combinations next-active 2)))))
    (= 'end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components)
                       next-active
                       conflicts))))
(defn get-conflicts-intervals [list-of-events]
  (let [components (map event-to-components list-of-events)
        sorted-components (sort-by (fn [x] (get x :timestamp)) (flatten components))]
    (walk-intervals sorted-components (set []) [])))
(get-conflicts-intervals [a b])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
(time (dorun (get-conflicts-intervals [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-naive [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(time (dorun (get-conflicts-intervals [t1 t2 t3 t4 t5 t1 t2 t3 t4 t5])))
(defn walk-intervals [components active conflicts]
  (cond
    (empty? components) conflicts
    (= :start (get (first components) :type))
     (let [next-active (conj active (get (first components) :name))
           next-conflicts (conj conflicts (map make-conflict (combo/combinations next-active 2)))]
       (walk-intervals (rest components) next-active next-conflicts))
    (= :end (get (first components) :type))
     (let [next-active (disj active  (get (first components) :name))]
       (walk-intervals (rest components) next-active conflicts))))
(defn event-to-components [e]
  [(->EventComponent (get e :start) :start (get e :name))
   (->EventComponent (get e :end) :end (get e :name))])
(get-conflicts-intervals [t1 t2 t3 t4 t5])
